name: Provision EC2, SSH, run hello-ecr/app.py

on:
  push:
    branches: [ "main", "master" ]
    paths:
      - "hello-ecr/**"
      - ".github/workflows/deploy-ec2.yml"
  workflow_dispatch:

jobs:
  ec2-ssh-run:
    runs-on: ubuntu-latest

    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: eu-west-1
      EC2_INSTANCE_NAME: gha-terraform-runner
      EC2_AMI_FILTER: "ubuntu/images/hvm-ssd/ubuntu-jammy-22.04-amd64-server-*"
      EC2_INSTANCE_TYPE: t3.micro
      SG_NAME: gha-ec2-sg
      ASSOCIATE_EIP: "true"
      APP_PORT: "5000"
      REPO_TO_CLONE: "https://github.com/iyoub00/TerraformECSFullDeployment.git"

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get default VPC
        id: vpc
        run: |
          VPC_ID=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text)
          echo "VPC_ID=$VPC_ID" >> $GITHUB_OUTPUT

      - name: Get latest Ubuntu 22.04 AMI
        id: ami
        run: |
          AMI_ID=$(aws ec2 describe-images \
            --owners 099720109477 \
            --filters "Name=name,Values=${EC2_AMI_FILTER}" "Name=state,Values=available" \
            --query 'Images | sort_by(@, &CreationDate)[-1].ImageId' \
            --output text)
          echo "AMI_ID=$AMI_ID" >> $GITHUB_OUTPUT

      - name: Ensure Security Group (22, 80/443, and APP_PORT open)
        id: sg
        run: |
          VPC_ID=${{ steps.vpc.outputs.VPC_ID }}
          SG_ID=$(aws ec2 describe-security-groups \
            --filters Name=group-name,Values=${SG_NAME} Name=vpc-id,Values=${VPC_ID} \
            --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)

          if [ "$SG_ID" = "None" ] || [ -z "$SG_ID" ]; then
            SG_ID=$(aws ec2 create-security-group --group-name ${SG_NAME} --description "GHA EC2 SG" --vpc-id $VPC_ID --query 'GroupId' --output text)

            if [ -n "${{ secrets.YOUR_IP_CIDR }}" ]; then
              aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 22  --cidr ${{ secrets.YOUR_IP_CIDR }}
            else
              aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 22  --cidr 0.0.0.0/0
            fi
            aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 80   --cidr 0.0.0.0/0
            aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port 443  --cidr 0.0.0.0/0
            aws ec2 authorize-security-group-ingress --group-id $SG_ID --protocol tcp --port ${APP_PORT} --cidr 0.0.0.0/0
          fi

          echo "SG_ID=$SG_ID" >> $GITHUB_OUTPUT

      # Ephemeral key pair
      - name: Generate ephemeral SSH key
        id: eph
        run: |
          ssh-keygen -t ed25519 -N "" -f /tmp/gha_ephemeral_key
          echo "EPH_KEY_NAME=gha-ephemeral-$(date +%s)" >> $GITHUB_OUTPUT

      - name: Import EC2 key pair
        run: |
          aws ec2 import-key-pair \
            --region ${{ env.AWS_REGION }} \
            --key-name ${{ steps.eph.outputs.EPH_KEY_NAME }} \
            --public-key-material fileb:///tmp/gha_ephemeral_key.pub

      - name: Launch or Reuse EC2 (replace if key mismatches)
        id: ec2
        env:
          KEY_NAME: ${{ steps.eph.outputs.EPH_KEY_NAME }}
        run: |
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${EC2_INSTANCE_NAME}" "Name=instance-state-name,Values=running,pending" \
            --query 'Reservations[0].Instances[0].InstanceId' --output text 2>/dev/null || true)

          if [ "$INSTANCE_ID" != "None" ] && [ -n "$INSTANCE_ID" ]; then
            CUR_KEY=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].KeyName' --output text)
            if [ "$CUR_KEY" != "${KEY_NAME}" ]; then
              echo "Existing instance $INSTANCE_ID uses key '$CUR_KEY' (expected '${KEY_NAME}'). Replacing it..."
              aws ec2 terminate-instances --instance-ids "$INSTANCE_ID" >/dev/null
              aws ec2 wait instance-terminated --instance-ids "$INSTANCE_ID"
              INSTANCE_ID=""
            fi
          fi

          if [ -z "$INSTANCE_ID" ] || [ "$INSTANCE_ID" = "None" ]; then
            INSTANCE_ID=$(aws ec2 run-instances \
              --image-id ${{ steps.ami.outputs.AMI_ID }} \
              --instance-type ${EC2_INSTANCE_TYPE} \
              --key-name ${KEY_NAME} \
              --security-group-ids ${{ steps.sg.outputs.SG_ID }} \
              --tag-specifications "ResourceType=instance,Tags=[{Key=Name,Value=${EC2_INSTANCE_NAME}}]" \
              --query 'Instances[0].InstanceId' --output text)
          fi

          echo "INSTANCE_ID=$INSTANCE_ID" >> $GITHUB_OUTPUT

          aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID"

          if [ "${ASSOCIATE_EIP}" = "true" ]; then
            ALLOC_ID=$(aws ec2 describe-addresses --query 'Addresses[?AssociationId==null].AllocationId' --output text | awk '{print $1}')
            if [ -z "$ALLOC_ID" ] || [ "$ALLOC_ID" = "None" ]; then
              ALLOC_ID=$(aws ec2 allocate-address --domain vpc --query AllocationId --output text)
            fi
            aws ec2 associate-address --instance-id "$INSTANCE_ID" --allocation-id "$ALLOC_ID" || true
          fi

          PUBLIC_IP=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "PUBLIC_IP=$PUBLIC_IP" >> $GITHUB_OUTPUT

      - name: Prepare SSH key
        run: |
          cp /tmp/gha_ephemeral_key key.pem
          chmod 600 key.pem

      - name: Wait for SSH
        run: |
          IP=${{ steps.ec2.outputs.PUBLIC_IP }}
          for i in {1..30}; do
            if nc -z $IP 22; then
              echo "SSH open"
              break
            fi
            echo "Waiting for SSH..."
            sleep 10
          done

      - name: Add host to known_hosts
        run: |
          mkdir -p ~/.ssh && chmod 700 ~/.ssh
          touch ~/.ssh/known_hosts && chmod 600 ~/.ssh/known_hosts
          ssh-keyscan -H ${{ steps.ec2.outputs.PUBLIC_IP }} >> ~/.ssh/known_hosts

      # --------- SETUP PYTHON + RUN hello-ecr/app.py AS A SERVICE ----------
      - name: Setup Python and run app.py
        run: |
          ssh -i key.pem -o StrictHostKeyChecking=yes ubuntu@${{ steps.ec2.outputs.PUBLIC_IP }} 'bash -s' << "EOF"
          set -e

          # System packages + Python bits
          sudo apt-get update -y
          sudo apt-get install -y git python3 python3-venv python3-pip

          # Clone or update repo
          if [ ! -d ~/TerraformECSFullDeployment ]; then
            git clone https://github.com/iyoub00/TerraformECSFullDeployment.git
          else
            cd ~/TerraformECSFullDeployment && git pull --ff-only
          fi

          cd ~/TerraformECSFullDeployment/hello-ecr

          # Python venv + deps
          python3 -m venv .venv
          source .venv/bin/activate
          pip install --upgrade pip
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
          deactivate

          # Create a systemd service to run app.py on boot + restart
          sudo bash -c 'cat > /etc/systemd/system/hello-ecr.service <<SERVICE
          [Unit]
          Description=hello-ecr Python app
          After=network.target

          [Service]
          User=ubuntu
          WorkingDirectory=/home/ubuntu/TerraformECSFullDeployment/hello-ecr
          Environment=PYTHONUNBUFFERED=1
          ExecStart=/home/ubuntu/TerraformECSFullDeployment/hello-ecr/.venv/bin/python app.py
          Restart=always
          RestartSec=5

          [Install]
          WantedBy=multi-user.target
  SERVICE'
  
  # Ensure app binds to 0.0.0.0:5000 inside app.py (Flask must listen externally)
  # If your app already does this, nothing else to do.
  
  # Start + enable service
  sudo systemctl daemon-reload
  sudo systemctl enable hello-ecr.service
  sudo systemctl restart hello-ecr.service
  
  # Show status once
  sudo systemctl --no-pager -l status hello-ecr.service || true
  EOF
# --------------------------------------------------------------------

- name: Access info
  run: |
    echo "EC2 Public IP: ${{ steps.ec2.outputs.PUBLIC_IP }}"
    echo "App URL: http://${{ steps.ec2.outputs.PUBLIC_IP }}:${{ env.APP_PORT }}/"

- name: Cleanup ephemeral key pair
  if: always()
  run: |
    aws ec2 delete-key-pair \
      --region ${{ env.AWS_REGION }} \
      --key-name ${{ steps.eph.outputs.EPH_KEY_NAME }} || true
