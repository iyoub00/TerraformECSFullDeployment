#name: Deploy to ECS Fargate
#
#on:
#  push:
#    branches:
#      - main
#      - develop
#  pull_request:
#    branches:
#      - main
#
#env:
#  AWS_REGION: eu-west-1
#  ECR_REPOSITORY: my-app-app
#  ECS_CLUSTER: my-app-cluster
#  ECS_SERVICE: my-app-service
#  ECS_TASK_DEFINITION: my-app-task
#  CONTAINER_NAME: my-app-container
#  TERRAFORM_STATE_BUCKET: my-terraform-state-ayoub-ecs-perso
#  TERRAFORM_LOCK_TABLE: terraform-state-lock
#
#jobs:
#  setup-backend:
#    name: Setup Terraform Backend
#    runs-on: ubuntu-latest
#    if: github.event_name == 'push'
#
#    steps:
#      - name: Configure AWS credentials
#        uses: aws-actions/configure-aws-credentials@v4
#        with:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-region: ${{ env.AWS_REGION }}
#
#      - name: Create S3 bucket for Terraform state
#        run: |
#          if ! aws s3api head-bucket --bucket ${{ env.TERRAFORM_STATE_BUCKET }} 2>/dev/null; then
#            echo "Creating S3 bucket..."
#            aws s3api create-bucket \
#              --bucket ${{ env.TERRAFORM_STATE_BUCKET }} \
#              --region ${{ env.AWS_REGION }} \
#              --create-bucket-configuration LocationConstraint=${{ env.AWS_REGION }}
#
#            echo "Enabling versioning..."
#            aws s3api put-bucket-versioning \
#              --bucket ${{ env.TERRAFORM_STATE_BUCKET }} \
#              --versioning-configuration Status=Enabled
#
#            echo "Enabling encryption..."
#            aws s3api put-bucket-encryption \
#              --bucket ${{ env.TERRAFORM_STATE_BUCKET }} \
#              --server-side-encryption-configuration '{
#                "Rules": [{
#                  "ApplyServerSideEncryptionByDefault": {
#                    "SSEAlgorithm": "AES256"
#                  }
#                }]
#              }'
#
#            echo "S3 bucket created and configured successfully"
#          else
#            echo "S3 bucket already exists"
#          fi
#
#      - name: Create DynamoDB table for state locking
#        run: |
#          if ! aws dynamodb describe-table --table-name ${{ env.TERRAFORM_LOCK_TABLE }} --region ${{ env.AWS_REGION }} 2>/dev/null; then
#            echo "Creating DynamoDB table..."
#            aws dynamodb create-table \
#              --table-name ${{ env.TERRAFORM_LOCK_TABLE }} \
#              --attribute-definitions AttributeName=LockID,AttributeType=S \
#              --key-schema AttributeName=LockID,KeyType=HASH \
#              --billing-mode PAY_PER_REQUEST \
#              --region ${{ env.AWS_REGION }}
#
#            echo "Waiting for table to be active..."
#            aws dynamodb wait table-exists \
#              --table-name ${{ env.TERRAFORM_LOCK_TABLE }} \
#              --region ${{ env.AWS_REGION }}
#
#            echo "DynamoDB table created successfully"
#          else
#            echo "DynamoDB table already exists"
#          fi
#
#  terraform:
#    name: Terraform Plan/Apply
#    runs-on: ubuntu-latest
#    needs: setup-backend
#    if: github.event_name == 'push'
#
#    defaults:
#      run:
#        working-directory: ./
#
#    steps:
#      - name: Checkout code
#        uses: actions/checkout@v4
#
#      - name: Configure AWS credentials
#        uses: aws-actions/configure-aws-credentials@v4
#        with:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-region: ${{ env.AWS_REGION }}
#
#      - name: Setup Terraform
#        uses: hashicorp/setup-terraform@v3
#        with:
#          terraform_version: 1.6.0
#
#      - name: Terraform Init
#        run: terraform init
#
#      - name: Terraform Format Check
#        run: terraform fmt -check
#        continue-on-error: true
#
#      - name: Terraform Validate
#        run: terraform validate
#
#      - name: Terraform Plan
#        run: terraform plan -out=tfplan
#        env:
#          TF_VAR_environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'dev' }}
#
#      - name: Terraform Apply
#        if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
#        run: terraform apply -auto-approve tfplan
#
#      - name: Get Terraform Outputs
#        id: terraform-outputs
#        run: |
#          echo "ecr_url=$(terraform output -raw ecr_repository_url)" >> $GITHUB_OUTPUT
#          echo "cluster=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
#          echo "service=$(terraform output -raw ecs_service_name)" >> $GITHUB_OUTPUT
#
#    outputs:
#      ecr_url: ${{ steps.terraform-outputs.outputs.ecr_url }}
#      cluster: ${{ steps.terraform-outputs.outputs.cluster }}
#      service: ${{ steps.terraform-outputs.outputs.service }}
#
#  build-and-deploy:
#    name: Build and Deploy Application
#    runs-on: ubuntu-latest
#    needs: terraform
#    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop')
#
#    steps:
#      - name: Checkout code
#        uses: actions/checkout@v4
#
#      - name: Configure AWS credentials
#        uses: aws-actions/configure-aws-credentials@v4
#        with:
#          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
#          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
#          aws-region: ${{ env.AWS_REGION }}
#
#      - name: Login to Amazon ECR
#        id: login-ecr
#        uses: aws-actions/amazon-ecr-login@v2
#
#      - name: Set up Docker Buildx
#        uses: docker/setup-buildx-action@v3
#
#      - name: Extract metadata for Docker
#        id: meta
#        uses: docker/metadata-action@v5
#        with:
#          images: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}
#          tags: |
#            type=ref,event=branch
#            type=sha,prefix={{branch}}-
#            type=raw,value=latest,enable={{is_default_branch}}
#
#      - name: Build and push Docker image
#        uses: docker/build-push-action@v5
#        with:
#          context: .
#          file: ./Dockerfile
#          push: true
#          tags: ${{ steps.meta.outputs.tags }}
#          labels: ${{ steps.meta.outputs.labels }}
#          cache-from: type=gha
#          cache-to: type=gha,mode=max
#          platforms: linux/amd64
#
#      - name: Download task definition
#        run: |
#          aws ecs describe-task-definition \
#            --task-definition ${{ env.ECS_TASK_DEFINITION }} \
#            --query taskDefinition > task-definition.json
#
#      - name: Fill in the new image ID in the Amazon ECS task definition
#        id: task-def
#        uses: aws-actions/amazon-ecs-render-task-definition@v1
#        with:
#          task-definition: task-definition.json
#          container-name: ${{ env.CONTAINER_NAME }}
#          image: ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ github.ref == 'refs/heads/main' && 'latest' || github.ref_name }}
#
#      - name: Deploy Amazon ECS task definition
#        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
#        with:
#          task-definition: ${{ steps.task-def.outputs.task-definition }}
#          service: ${{ env.ECS_SERVICE }}
#          cluster: ${{ env.ECS_CLUSTER }}
#          wait-for-service-stability: true
#
#      - name: Verify deployment
#        run: |
#          echo "Deployment completed successfully!"
#          echo "Service: ${{ env.ECS_SERVICE }}"
#          echo "Cluster: ${{ env.ECS_CLUSTER }}"
#
#          aws ecs describe-services \
#            --cluster ${{ env.ECS_CLUSTER }} \
#            --services ${{ env.ECS_SERVICE }} \
#            --query 'services[0].loadBalancers[0].targetGroupArn' \
#            --output text
#
#  notify:
#    name: Notify Deployment Status
#    runs-on: ubuntu-latest
#    needs: build-and-deploy
#    if: always()
#
#    steps:
#      - name: Deployment Success
#        if: needs.build-and-deploy.result == 'success'
#        run: |
#          echo "Deployment successful!"
#          echo "Environment: ${{ github.ref == 'refs/heads/main' && 'production' || 'development' }}"
#
#      - name: Deployment Failed
#        if: needs.build-and-deploy.result == 'failure'
#        run: |
#          echo "Deployment failed!"
#          exit 1